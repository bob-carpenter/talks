---
title: "Stan C++ Development:<br/>Adding a New Function"
author: "Bob Carpenter & Sean Talts"
date: "August 2018"
output:
  ioslides_presentation:
    css: styles.css
  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## GitHub Resources

* `stan-dev/math`: [Adding a new function with known gradients](https://github.com/stan-dev/math/wiki/Adding-a-new-function-with-known-gradients)

* `stan-dev/stan`: [Contributing new functions to Stan](https://github.com/stan-dev/stan/wiki/Contributing-New-Functions-to-Stan)

* `stan-dev/stan`: [Developer process overview](https://github.com/stan-dev/stan/wiki/Developer-process-overview)

* `stan-dev/math`: [Developer doc](https://github.com/stan-dev/math/wiki/Developer-Doc)

## Placeholder slide for diagram
diagram will show something like: 

* Stan compiler source compiles with C++ compiler to Stan compiler
* Stan language model compiles with Stan compiler to C++ model
* C++ model includes Math library
* C++ model compiles with C++ compiler to program
* program is fed data and spits out draws

## Stan language is translated to a C++ model
* Creates a C++ model class with a known interface
* Model class is constructed with the data you pass in when you go to fit the model
* Primary entry point on the class is the `log_prob` function
    - Takes in parameter values and returns their log probability density (potentially up to a constant)

## The Stan<>C++ translator
* Called many things - compiler, transpiler, parser
* Also written in C++
* Lives in the Stan repo alongside the algorithms and services (`lang`)
* Functions are first defined in the Math library and then exposed in the Stan language

## C++ model is compiled into a program
* Includes the Math library - most or all functions and data types are defined there
* Compiled with the Stan algoirthms
* Some basic functionality for I/O lives in CmdStan, which presents the interface a user sees on the command line

## Current repo structure
CmdStan -> Stan -> Math

* Uses git submodules
* CmdStan has the Stan repo as a git submodule at `stan/`
* Stan has the Math library as a git submodule at `lib/stan_math`
* Math library directly includes (not as submodules) some external libraries like boost at `lib/`

## A Stan program
* `Matrix program(Matrix data) {...}`
    - Function from data to a sample of parameter draws typical given that data and model
* Compiled with a few algorithms that use the model density to find typical parameter draws
* Most of the complexity lies in the likelihood and is built using functions in the Math library

## Most of "Stan" is the Math library
* Provides users with many functions to express complicated likelihoods
* Autodiff system gives the algorithms the gradients they need automatically for any Stan or Math library code
* Split up into `stan` and `test`
* Then split by autodiff mode: `prim`, `rev`, `fwd`, `mix`
* Then further split by container type: `scal`, `arr`, `mat` (this is going away)
* Sometimes further split up by functionality: `err`, `fun`, `meta`, `prob`, ...

## Tests and continuous integration
* We use [googletest](https://github.com/google/googletest), a C++ testing framework for unit tests
    - tests end in `_test.cpp`
    - provides macros like `TEST(SuiteName, TestName)` and `EXPECT_EQ(actual, expected)`
* Test directory structure parallel to `src` stucture
* Run tests locally with `runTests.py` helper script on a directory or test
* Jenkins at http://d1m1s1b1.stat.columbia.edu:8080/
    - Specified in code, in a top-level file named `Jenkinsfile`
* [This wiki](https://github.com/stan-dev/stan/wiki/Supported-C---Compilers-and-Language-Features) tries to collate which OSes and toolchains are tested

## Developer process
0. For larger changes only: Discourse discussion and/or design review
1. Github issue describing the problem 
2. Add a description of the proposed technical solution to the github issue
3. Create a GitHub pull request
4. [Code Review](https://github.com/stan-dev/math/wiki/Developer-Doc#code-review-guidelines)
5. Merge

## Setting up GitHub
* Create an account
* (optional) [Set up SSH keys](https://help.github.com/articles/connecting-to-github-with-ssh/)
* Fork repo(s) from stan-dev
* `git clone --recursive <cmdstan repo>`
* Add your fork as a remote on the repo you care about

## Clone CmdStan
```{r, out.width = "100%"}
knitr::include_graphics("img/clone cmdstan.png")
```

## Fork Math repo
```{r, out.width = "100%"}
knitr::include_graphics("img/fork.png")
```


## My fork 
![](img/my fork.png)

## Set up fork as remote in local clone of CmdStan
```
$ git remote -v
origin	git@github.com:stan-dev/math.git (fetch)
origin	git@github.com:stan-dev/math.git (push)
$ git remote add sean git@github.com:seantalts/math.git
$ git remote -v
origin	git@github.com:stan-dev/math.git (fetch)
origin	git@github.com:stan-dev/math.git (push)
sean	git@github.com:seantalts/math.git (fetch)
sean	git@github.com:seantalts/math.git (push)
```

## Creating a PR
Fairly standard open source flow:

1. (optional) create a branch
1. write code, tests, and doc
1. add files
1. commit with a [message about what you were trying to accomplish](https://chris.beams.io/posts/git-commit/) 
1. `git push origin <branchname>`
1. open PR on appropriate `stan-dev` repo

## Creating a branch
```
$ git checkout -b descriptive-branch-name
Switched to a new branch 'descriptive-branch-name'
```

## Add, commit, push
```
$ git add stan/math/gpu/matrix_gpu.hpp
$ git commit -m "Informative message..."
$ git push sean descriptive-branch-name
```

## PR step 1
```{r, out.width = "100%"}
knitr::include_graphics("img/PR1.png")
```

## PR step 2
```{r, out.width = "100%"}
knitr::include_graphics("img/PR2.png")
```

## PR step 3
```{r, out.width = "100%"}
knitr::include_graphics("img/PR3.png")
```